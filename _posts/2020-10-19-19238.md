---
layout: post
title: "백준 19238번 스마트 택시"
date: 2020-10-19
excerpt: "푸는중"
tags: []
comments: true
---
``` c++
#include <bits/stdc++.h>
#define MAX 21
using namespace std;
// 최단 거리 승객 , 행 번호 , 열 번호
// 승객 번호는 2부터 시작해서 mp저장
// 도착 지점은 -2부터 시작해서 mp저장
// mp가 2이상이면 find
// 0이하면 continue 
// 1이면 block
// queue에서 도착지가 나올경우 각각의 점들중에 우선순위 높은거 out
bool cmp(pair<int,int> p1,pair<int,int> p2)
{
	if(p1.first == p2.first)
	{
		return p1.second < p2.second; 
	}
	return p1.first < p2.first;
}
int mp[MAX][MAX];
int N, M, F;
int dx[4] = {0, 1, -1, 0};
int dy[4] = {-1, 0, 0, 1};
pair<int,int> start;
int ed;
struct P
{
	//(Y,X)
	pair<int, int> start;
	pair<int, int> end;
};
P p[401];
void seeM()
{
	for (int i = 1; i <=N; i++)
	{
		for (int j = 1; j<=N; j++)
		{
			cout << mp[i][j] << " ";
		}
		cout << "\n";
	}
	cout << "\n";
}

// bfs 시작 위치 , 남은 연료
// return 남은연료
// 시민 찾는 bfs
int bfsS(int f)
{
	bool vst[MAX][MAX];
	memset(vst,false,sizeof(vst));
	int x = start.second;
	int y = start.first;
	//Y,X,사용 연료
	queue<pair<pair<int,int>,int>> q;
	q.push({start,0});
	vst[y][x] = true;
	while(!q.empty())
	{
		int curx = q.front().first.second;
		int cury = q.front().first.first;
		int curf = q.front().second;
		q.pop();
		if(mp[cury][curx]>=2) // 시민을 발견
		{
			start.first = cury;
			start.second = curx;
			ed = mp[cury][curx];
			mp[cury][curx] = 0;
			return f-curf;
		}
		if(curf>f)
		{
			break;
		}
		for(int i=0;i<4;i++)
		{
			int nx = curx+dx[i];
			int ny = cury+dy[i];
			if(nx <=0 ||nx >N || ny <=0 || ny>N) continue;
			if(mp[ny][nx]==1) continue;
			if(vst[ny][nx]) continue;
			vst[ny][nx] = true;
			q.push({{ny,nx},curf+1});
		}
	}
	//못 찾을 경우
	return -1;
}


// bfs 시작 위치 , 남은 연료 , 도착해야하는 지점
// return 남은연료
// 도착지점 찾는 bfs
int bfsE(int f)
{
	bool vst[MAX][MAX];
	memset(vst,false,sizeof(vst));
	int x = start.second;
	int y = start.first;
	//Y,X,사용 연료
	queue<pair<pair<int,int>,int>> q;
	q.push({start,0});
	vst[y][x] = true;
	while(!q.empty())
	{
		int curx = q.front().first.second;
		int cury = q.front().first.first;
		int curf = q.front().second;
		q.pop();
		// 도착지점을 발견
		if(mp[cury][curx] == -ed) 
		{
			start.first = cury;
			start.second = curx;
			mp[cury][curx] = 0;
			return f+curf;
		}
		if(curf>f)
		{
			break;
		}
		for(int i=0;i<4;i++)
		{
			int nx = curx+dx[i];
			int ny = cury+dy[i];
			if(nx <=0 || nx >N || ny <=0 || ny>N) continue;
			if(mp[ny][nx]==1) continue;
			if(vst[ny][nx]) continue;
			vst[ny][nx] = true;
			q.push({{ny,nx},curf+1});
		}
	}
	//못 찾을 경우
	return -1;
}

int main()
{
	//ios::sync_with_stdio(false);
	//cin.tie(NULL);
	//cout.tie(NULL);
	cin >> N >> M >> F;
	for (int i = 1; i <= N; i++)
	{
		for (int j = 1; j <= N; j++)
		{
			cin >> mp[i][j];
		}
	}
	//(Y,X)
	cin >> start.first >> start.second; //(Y,X);
	for(int i=2;i<M+2;i++)
	{
		cin >> p[i].start.first >> p[i].start.second >> p[i].end.first >> p[i].end.second;
		mp[p[i].start.first][p[i].start.second] =i;
		mp[p[i].end.first][p[i].end.second] =-i;
	}
	int restf = F;
	int ans=-1;
	for(int i=0;i<M;i++)
	{
		restf = bfsS(restf);
		if(restf == -1)
		{
			ans == -1;
			break;
		}
		//seeM();
		restf = bfsE(restf);
		if(restf == -1)
		{
			ans == -1;
			break;
		}
		//seeM();
		ans = restf;
	}

	cout << restf;
}
```